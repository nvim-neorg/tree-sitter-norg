%Use many examples!%
%And also provide counter-examples for cases which are not expected to work!%
%Should speech marks ("") be attached modifiers? Imo it could be pretty useful to have them as that%

- |-| add table syntax (cells) (`:`-detached modifier)
-- |x| grammar
-- | | documentation
- |x| make sure that no whitespace can appear at linkable boundaries
- |x| swap strong attribute and non-verbatim ranged tag characters
- |x| explain differentation of verbatim and non-verbatim tags in spec
- |-| support and document line number in file links
-- | | support line numbers in `{:file:123}` links?
- |x| reverse heading links to be per-level
- |x| support `?`-linkable target (wiki link)
- |_| add anonymous node for ellipsis (`...`)
- |x| refactor free-form attached mods to place `|` inside the attached mods
-- |x| TODO: tests
- |x| raise precedence of escape character between standard and free-form verbatim markup
- | | document intersection modifiers: `<space><char><space>`
-- | | document and support paragraph_segment delimiter: |` : `|
-- | | document and support notice modifier: |` ! `|
- |x| add attached modifier extensions (attributes: `*bold*(attribute)`)
-- |x| grammar
-- |-| tests (TODO: add more)
-- | | documentation
- |x| remove markers
- | | document and add attribute detached modifier `%` (standard but logical (cannot be linked to))
- | | Add `>`, `<` detached modifier extensions (GTD-based)
- | | Add timestamp ranges (`Tue 3rd Jul - Thu 5th Jul`)
- |?| Document standard library macros/attributes?

* Norg File Format Specification
  This file contains the formal file format specification of the Norg syntax version 0.1.
  This document is written in the Norg format in its original form and, thus, attempts to be
  self-documenting.

  Please note that this is *not* a reference implementation - this is an established ruleset that should
  be strictly followed.

* Introduction
  Before diving into the details we will start with an introduction. The Norg file format was
  designed as part of the [Neorg]{https://github.com/nvim-neorg/neorg} plugin for Neovim which was
  started by /Vhyrro (@vhyrro)/ in April of 2021. Soon after starting this work, /Max Rossmannek
  (@mrossinek)/ joined the development team, and, with the help of the [Neorg] community, the two
  have shaped the Norg syntax to what it has become today.

** What is Norg?
   The Norg syntax is a /structured/ plain-text file format which aims to be human readable when
   viewed standalone while also providing a suite of markup utilities for typesetting structured
   documents. Compared to other plain-text file formats like e.g. Markdown, RST or AsciiDoc, it sets
   itself apart most notably by following a strict philosophy to abide by the following simple
   rules:
   ~ *Consistency:* the syntax should be consistent. Even if you know only a part of the syntax,
     learning new parts should not be surprising and rather feel predictable and intuitive.
   ~ *Unambiguity:* the syntax should leave _no_ room for ambiguity. This is especially motivated by
     the use of [tree-sitter]{https://tree-sitter.github.io/tree-sitter/} for the original syntax
     parser which takes a strict left-to-right parsing approach and only has single-character
     look-ahead.
   ~ *[Free-form]{https://en.wikipedia.org/wiki/Free-form_language}:* whitespace is _only_ used to
     delimit tokens but has no other significance! This is probably the most contrasting feature to
     other plain-text formats which often adhere to the
     [off-side rule]{https://en.wikipedia.org/wiki/Off-side_rule}, meaning that the syntax relies on
     whitespace-indentation to carry meaning.

   Although built with [Neorg] in mind, Norg can be utilized in a wide range of applications,
   from external note taking plugins to even messaging applications. Thanks to its {:layers:}[layer]
   system you can choose the feature set you want to support, and can ignore the higher levels.
   %TODO: should we move the layers into this document?%
   %I would argue so, but we would need to re-evaluate their validity and find a good location here%

* Preliminaries
  First, we define some basic concepts which will be used in this specification.

** Characters
   A Norg file is made up of /characters/.
   A <character> is any Unicode [code point]{https://en.wikipedia.org/wiki/Code_point}.

*** Whitespace
    A {** characters}[character] is considered *whitespace* if it is any of the following:
    - A tab `U+0009`
    - A line feed `U+000A`
    - A form feed `U+000C`
    - A carriage return `U+000D`
    - Any code point in the
      [Unicode Zs general category]{https://www.fileformat.info/info/unicode/category/Zs/list.htm}
      (includes the normal space `U+0020`)

    Any combination of the above is also considered whitespace.

    Tabs are not expanded to spaces and since whitespace has no semantic meaning there is no need
    to define a default tab stop. However, if a parser must (for implementation reasons) define a
    tab stop, we suggest to set it to 4 spaces.

    The following whitespace combinations are a <line ending>:
    - A single line feed
    - A single carriage return
    - A carriage return immediately followed by a line feed

    Blank lines are irrelevant in Norg because standalone whitespace has no semantic relevance.

*** Alphanumeric Characters
    An alphanumeric character is any character that is *not* {*** punctuation}, nor is it any
    {*** special characters}[special character]. In the English alphabet, an alphanumeric character
    means all letters from the alphabet (uppercase/lowercase) and all numbers:
    `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789`.

    It is important to note that {*** alphanumeric characters} do *not* include {*** whitespace}.

*** Punctuation
    A {** characters}[character] is considered to be *punctuation* if it is any of the following:
    - A standard ASCII punctuation character: `| !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ |`
    - A Unicode punctuation character is an ASCII punctuation character or anything in the general
      Unicode categories `Pc`, `Pd`, `Pe`, `Pf`, `Pi`, `Po`, or `Ps`.

*** Escaping
    A single {** characters}[character] can be escaped if it is immediately preceded by a backslash,
    `|\|` (`U+005C`). Any {** characters}[character] may be escaped /apart from/ {** characters}
    within free-form verbatim segments (see {** free-form attached modifiers}).
    For more information about precedence, take a look at the {* precedence} section.

*** Special Characters
    %TODO: how do non-latin characters work? If they go in here, they do not form words as below...%
    %I suggest, that by default we treat any non-covered case the same as alphanumeric characters.%
    %We could even go as far as to not define those in the first place as their own category...%

** Words
   The Norg format is designed to be parsed on a word-by-word basis from left-to-right through the
   entire document /in a single pass/. This is possible because the language is [free-form], meaning
   that whitespace has no semantic meaning, and because the markup follows strict rules which are
   outlined in the later sections of this document.

   A *word* is considered to be any combination of {** characters} which are neither
   {*** whitespace}, {*** punctuation} nor other {*** special characters}.

** Paragraph Segments
   {** Words} are first combined into *paragraph segments*. A paragraph segment may then contain any
   inline element of type:
   - {* attached modifiers}
   - {* linkables}

   A {# line ending} terminates the paragraph segment. This means that a paragraph segment is
   essentially just a line of text:
   @code norg
   I am a paragraph segment.
   I am another paragraph segment.
   And together we form a paragraph.
   @end

** Paragraphs
   Paragraphs are then formed of consecutive {** paragraph segments}. A paragraph is terminated by:
   - A <paragraph break> (which equals two consecutive {# line ending}s)
   - Any of the {* detached modifiers}
   - Any of the {* delimiting modifiers}
   - Any of the {** ranged tags}
   - Any of the {*** strong carryover tags}

* Detached Modifiers
  Norg has several detached modifiers. The name originates from their differentiation to the
  {* Attached Modifiers}, which will be discussed later.

  All detached modifiers must abide by the following rules:
  - A detached modifier can _only_ occur at the beginning of the line (arbitrary {*** whitespace}
    (but nothing else!) may precede it)
  - A detached modifier must be immediately followed by {*** whitespace} (excl. {# line ending}s!),
    another detached modifier of the same type or by any of the {# detached modifier extensions}

  The following list outlines all valid *detached* modifiers. The list also adds various possible
  properties to each category which will be explained in more detail below.
  - `*`: {*** Headings} (structural, nestable)
  - `-`: {*** Unordered Lists} (nestable)
  - `~`: {*** Ordered Lists} (nestable)
  - `>`: {*** Quotes} (nestable)
  - `$`: {*** Definitions} (range-able)
  - `^`: {*** Footnotes} (range-able)
  - | | `<`: add drawers/details (range-able)
  - | | `&`: add variables (range-able, logical)
  - | | `=`: add macros (range-able, logical)
  - | | `:`: add cells (range-able, logical)
  - | |`%`: add attribute (logical)

  %TODO: improve formatting of the above. As a table?%

** Grouping
   Both nestable and range-able detached modifiers have a unique quality - when several consecutive
   modifiers /of the same type/ are encountered (by consecutive we mean _NOT_ separated via a
   {# paragraph break}), they are treated as one whole <object>. This is crucial to understand as
   it is required for the many types of {** carryover tags} to function.

*** Examples
    @code norg
    The following items naturally group because they are range-able, forming
    a definition list:
    $ Term 1
      Definition 1!
    $ Term 2
      Definition 2!
    @end

    @code norg
    Together, these form one whole unordered list:
    - List item 1
    - List item 2
    @end

    @code norg
    - List item in one list

    - This item is in another list, because we used a {# paragraph break} to split these items
    @end

** Structural Detached Modifiers
   The first detached modifier type is the /structural/ modifier type. As the name suggests,
   modifiers under this category *structure* the Neorg document in some form or another.

   After a structural modifier, one {# paragraph segments}[paragraph segment] is consumed as the
   /title/ of the modifier.

   A property of {** structural detached modifiers} is that they consume *all* other non-structural
   detached modifiers, lower-level structual modifiers, inline markup and {** paragraphs};
   they are the most important detached modifier in the hierarchy of modifiers.

   To manually terminate a structural detached modifier (like a heading) you must use a
   {** delimiting modifiers}[delimiting modifier], or you simply use another structural modifier of
   the same level.

*** Headings
    @code norg
    * Heading level 1
    ** Heading level 2
    *** Heading level 3
    **** Heading level 4
    ***** Heading level 5
    ****** Heading level 6
    ******* Heading level 7 (falls back to level 6 in the tree-sitter parser)
    @end

    Although headings are both structural /and/ nestable (see next section), the former takes
    precedence over the latter, meaning that headings only affect a single
    {** paragraph segments}[paragraph segment] as their title. This is for user convenience as it
    does not require an empty line right below a heading. Because of this precedence headings are
    also non-{** grouping}.

    Headings serve as a way to categorize and organize other elements into smaller chunks for better
    readability.

** Nestable Detached Modifiers
   Nestable detached modifiers are a kind which may be repeated multiple times in order to produce a
   _nested_ object of the given type. The nesting levels are capped at 6 in the [tree-sitter] parser
   but longer repetitions of the same modifier are allowed, falling back to the sixth nesting level.
   Other parsers may choose to support higher nesting levels.

   Furthermore, in contrast to the {# standard detached modifiers} this detached modifier type has
   /no/ title, and affects the following `paragraph` instead of only the next
   {# paragraph segments}[paragraph segment]. Said paragraph then becomes the modifier's /content/.
   This means that in order to terminate the detached modifier contents, you need two consecutive
   line breaks (see {# paragraph break}).

   Here are some correct examples of nestable detached modifiers:

*** Unordered Lists
    Unordered lists provide an easy way to enumerate items in an unordered fashion. Useful for data
    that's categorically similar but doesn't need to follow a strict order.

    @code norg
    - Unordered list level 1
    -- Unordered list level 2
    --- Unordered list level 3
    ---- Unordered list level 4
    ----- Unordered list level 5
    ------ Unordered list level 6
    ------- Unordered list level 7 (falls back to level 6 in the tree-sitter parser)

    - Unordered list level 1
      This text is still part of the level 1 list item.
    -- Unordered list level 2
       This text is still part of the level 2 list item.
    --- Unordered list level 3
        This text is still part of the level 3 list item.
    ---- Unordered list level 4
         This text is still part of the level 4 list item.
    ----- Unordered list level 5
          This text is still part of the level 5 list item.
    ------ Unordered list level 6
           This text is still part of the level 6 list item.
    ------- Unordered list level 7 (falls back to level 6 in the tree-sitter parser)
            This text is still part of the level 7 list item.
    @end

*** Ordered Lists
    This list type is only useful for data that needs to be kept in sequence. In contrast to other
    formats which may use a syntax like `1.`/`1)`, Norg counts the items automatically - this
    reduces complexity and makes reordering items simple.

    @code norg
    ~ Ordered list level 1
    ~~ Ordered list level 2
    ~~~ Ordered list level 3
    ~~~~ Ordered list level 4
    ~~~~~ Ordered list level 5
    ~~~~~~ Ordered list level 6
    ~~~~~~~ Ordered list level 7 (falls back to level 6 in the tree-sitter parser)

    ~ Ordered list level 1
      This text is still part of the level 1 list item.
    ~~ Ordered list level 2
       This text is still part of the level 2 list item.
    ~~~ Ordered list level 3
        This text is still part of the level 3 list item.
    ~~~~ Ordered list level 4
         This text is still part of the level 4 list item.
    ~~~~~ Ordered list level 5
          This text is still part of the level 5 list item.
    ~~~~~~ Ordered list level 6
           This text is still part of the level 6 list item.
    ~~~~~~~ Ordered list level 7 (falls back to level 6 in the tree-sitter parser)
            This text is still part of the level 7 list item.
    @end

*** Quotes
    @code norg
    > Quote level 1
    >> Quote level 2
    >>> Quote level 3
    >>>> Quote level 4
    >>>>> Quote level 5
    >>>>>> Quote level 6
    >>>>>>> Quote level 7 (falls back to level 6 in the tree-sitter parser)

    > Quote level 1
      This text is still part of the level 1 quote.
    >> Quote level 2
       This text is still part of the level 2 quote.
    >>> Quote level 3
        This text is still part of the level 3 quote.
    >>>> Quote level 4
         This text is still part of the level 4 quote.
    >>>>> Quote level 5
          This text is still part of the level 5 quote.
    >>>>>> Quote level 6
           This text is still part of the level 6 quote.
    >>>>>>> Quote level 7 (falls back to level 6 in the tree-sitter parser)
            This text is still part of the level 7 quote.
    @end

*** Invalid Examples
    - \
        @code norg
        >I am not a quote

        some preceding text > I am also not a quote

        >- I am not a valid detached modifier

        > > I am only a level 1 quote

        *
            I am not a valid heading title.
        @end
    - Headings are also /nestable/ detached modifiers but will only be discussed later as part of the
      {# structural detached modifiers} section.

** Range-able Detached Modifiers
   Range-able detached modifiers can occur in two forms:
   - As a single detached modifier they affect:
   -- The next `paragraph_segment` which becomes the /title/
   -- Any following paragraph which becomes the /content/ .
   - As a pair of two detached modifiers in which case:
   -- The next `paragraph_segment` still becomes the /title/
   -- The content continues until the "closing" detached modifier is found

   The closing modifier has the same rules as an opening detached modifier except it /must/ be
   directly succeeded by a {# line ending} in contrast to the whitespace character which follows the
   opening modifier.

*** Definitions
    Definitions are primarily of use to people who write technical documents.
    They consist of a term, and then are followed by a definition of that term.

    @code norg
    $ Term
    Definition content.
    @end

    To create longer definitions, use the ranged definition syntax instead:
    @code norg
    $$ Term
    Content of the definition.

    Which scans up to the closing modifier.
    $$
    @end

*** Footnotes
    Footnotes allow the user to give supplementary information related to some text without
    polluting the paragraph itself. Footnotes can be linked to using {# linkables}.

    @code norg
    ^ Single Footnote
    Optional footnote content.
    @end

    To create longer footnotes, use the ranged term instead:
    @code norg
    ^^ Ranged Footnote
    Content of the footnote.

    Which scans up to the closing modifier.
    ^^
    @end

*** | | Drawers/Details
    The `<` char.

*** | | Variables
    The `&` char.

*** | | Macros
    The `=` char.

*** | | Attribute
     The `%` char.

** Delimiting Modifiers
   In Norg, headings (and other {** structural detached modifiers}) must be terminated by a {**
   delimiting modifiers}[delimiting modifier]. This kind of modifier must abide by the following
   rules:
   - A delimiting modifier can _only_ occur at the beginning of the line (arbitrary {# whitespace}
     (but nothing else!) may precede it)
   - A delimiting modifier must consist of three or more consecutive modifiers of the same
     type (see also {^ disambiguating delimiting modifiers})
   - It must be followed by an immediate {# line ending} (without any extra {# whitespace})

   ^^ Disambiguating delimiting modifiers
   In order to make delimiting modifiers unambiguous the three char rule/no succeeding whitespace
   rules were put into place:
   - Using three modifiers helps to disambiguate the endings of {** range-able detached modifiers}
     (e.g. `==`).
   - If succeeding whitespace were allowed ambiguity would arise between nested unordered list items
     and the `---` delimiting modifier.
   ^^

*** Weak Delimiting Modifier
    This modifier uses the `-` character and immediately closes the /current/ heading level
    (decreases the current nesting level by one).
    @code norg
    * Heading level 1
      Text under first level heading.

    ** Heading level 2
       Text under second level heading.
       ---

      Text under first level heading again.
    @end

*** Strong Delimiting Modifier
    This modifier uses the `=` character and immediately closes all heading levels.
    @code norg
    * Heading level 1
      Text under first level heading.

    ** Heading level 2
       Text under second level heading.
       ===

    Text belonging to no heading level (i.e. to the document's root).
    @end

*** Horizontal Rule
    This modifier uses the `_` character and simply renders a horizontal line. It does _NOT_
    affect the heading level but immediately terminates a {# paragraphs}[paragraph].
    @code norg
    * Heading level 1
      Text under first level heading.
      ___
      This is a new paragraph separated from the previous one by a horizontal line.
      This text still belongs to the first level heading.
    @end

** Detached Modifier Extensions
   {# Detached modifiers} support extensions which must immediately follow the detached modifier
   (or another extension).

*** TODO Status Extension
    The TODO item extension assigns a task status to a certain modifier. You probably know this
    concept from Org where unordered lists can become tasks. In Norg we take this concept to
    the next level because any detached modifier can be assigned a task status. This can for
    example be useful for the author of a document to keep track of the status of certain sections.
    The syntax is the following:
    - A TODO status extension starts with a `|` char
    - Immediately a single status indicator character must follow. The following statuses are
      supported:
    -- |` `|: undone (a literal space)
    -- `x`: done
    -- `?`: needs further input/clarification
    -- `!`: urgent
    -- `+`: recurring (with an optional {**** timestamp extension}[timestamp])
    -- `-`: in-progress/pending
    -- `=`: on hold
    -- `_`: put down/cancelled
    - Finally another `|` char closes the todo status extension.

   NOTE: The TODO status extension /must/ be followed by whitespace (excluding {# line ending}s).

*** Advanced Detached Modifier Extensions
    Apart from just being able to assign a TODO state it is also possible to apply more complex
    states with parameters to certain indicators. Such examples are the {**** timestamp extension}
    or the {**** priority extension}.
    The syntax is very simple - an indicator char (e.g. the `+` indicator described above) may be
    succeeded by a single {# whitespace} character and then a set of {** words} (without newlines)
    follow. This set of {** words} then becomes the parameters for the indicator.

    For example:
    @code norg
    - |+ 5th July| This task recurs every 5th of July.
    - |# A|@ 3rd feb| This task has a priority `A` and is assigned to the 3rd of February.
    @end
    Not all {** detached modifier extensions} support parameters and for good reason. There is no
    need to attach extra metadata to a done or undone state for instance.

    Below are descriptions for a few other extensions that may be used.

**** Timestamp Extension
     The timestamp extension allows you to associate a {* detached modifiers}[detached modifier]
     with a date/time.
     The syntax for a timestamp is as follows: `<day>,? <day-of-month> <month> <year> <time> <timezone>`

     Examples:
     - `Sat, 29 Oct 1994 19:43:31 GMT`
     - `Thu 12th Jan 2022`

     Obviously, you're not required to type the whole syntax out very time. Any of the elements in
     angled brackets (`<>`) can be dropped/ignored, but the order of those values may not change!

     Here is a detailed index of all possible alterations for each value:

     $$ <day>
     The `<day>` value is reliant on the current locale, but the following alterations of that
     value are permitted:
     - Full version (e.g. `Tuesday`, `Wednesday`)
     - Shorthand, three letter version (e.g. `Tue`, `Wed`)
     - Shorthand, more-than-three letter version (`e.g. `Thur`, `Frida`) (useful when very quickly jotting
       down dates)

     %TODO: When releasing the first release candidate ask people to add ideas here%
     $$

     %TODO: finish this%

**** Priority Extension
     This extension allows for you to specify a priority of your detached modifier extension.

     The syntax is as follows:
     @code norg
     * |# A| This heading has priority A (highest priority)
     @end
     Note that Norg does not specify strict semantics for this detached modifer extension, and as
     such there is no set-in-stone way to specify priorities. The most common (and recommended) way
     to specify priorities is to go from `A-Z`, but many also prefer `0-9` or even named priorities
     like `LOW`\/`MEDIUM`\/`HIGH`.

     [Neorg]'s [GTD]{https://hamberg.no/gtd} implementation even repurposes the priority for use as
     contexts, so yes, this detached modifier extension is very vertasile.

**** Due Date Extension
     As the name suggests, this extension marks something as "due before x", where x is a
     {**** timestamp extension}[timestamp]. Especially useful in [GTD] and other forms of note
     taking and time management applications.

     Syntax:
     @code norg
     - |< Tue 5th Feb| Do this before the 5th february.
     @end

**** Start Date Extension
     A counterpart to the {**** due date extension} - defines when a task *begins*. Also useful in
     [GTD].

     Syntax:
     @code norg
     - |> Tue 5th Feb| This task starts after the 5th february.
     @end

*** Indent Segment Extension
    Since {# nestable detached modifiers} can only contain a {# paragraphs}[paragraph] this can cause severe
    limitations because the insertion of e.g. code blocks is not possible. To alleviate
    this deficiency, the {# indent segment extension} exists, which increases the indentation of the
    tree by one level allowing nesting of more complex elements to occur. The syntax is the
    following:
    - The indent segment extension starts with a single `\` char
    - This must be _immediately_ followed by a {# line ending}. Thus, the start node of this
      extension can be seen as a {# trailing modifier}.
    - The contents follow
    - The extension ends when:
    -- Another {# nestable detached modifier} of the /same or higher/ nesting level occurs.
       A "higher" nesting level is one that is dominant in the hierarchy of list item nodes.
       That is, a level 1 list item is considered "higher up" than a level 2 and level 3 list item,
       and a level 3 list item is considered "higher up" than a level 4 or 5 list item
    -- When the indentation is manually closed with one of the {# delimiting modifiers}
    -- When a {# structural detached modifiers}[structural detached modifier] is encountered

    @code norg
    - \
      The indent segment extension has started.

      I can now include multiple paragraphs within this list item.

      @code lua
      print("Even code blocks are allowed!")
      @end

      ^ Range-able detached modifiers can be inserted, too.

      ---
    - Another nestable detached modifier ends the indent segment
    - However, in this example I already closed the indent segment manually with `---`
    @end
    %TODO: we need to convert all example ranged tags, right?%

* Tags
  The main differentiator from simple markup formats and more complex ones is the ability to define
  data and extensions for the format. Norg allows for you to extend its syntax and define data
  within clear boundaries - it does this using tags.

  Tags are Norg's official way of extending its own syntax. It's the /only/ way that extensions
  may be made to the format.

  There are 5 different tag types, each with their own way of changing the way text in Norg is
  interpreted. Before we discuss those, however, we should discuss the syntax rules for tags:
  - A tag is similar to a {# detached modifiers}[detached modifier] in the sense that it must begin
    at the beginning of a line with optional {# whitespace} (but nothing else) preceding it.
  - After that you will encounter the special tag character (`@`, `|`, `+`, `#` and `=`), /none/ of
    which are attached modifiers (if those characters were attached modifiers then we wouldn't know
    whether or not the character is an attached modifier opener or a tag opener until we would have
    parsed the whole line; in other words, we would be dealing with ambiguity). The special tag
    character is then /immediately/ followed by text, which becomes the /tag name/. Said tag name
    can consist of any {# alphanumeric characters}[alphanumeric character] and/or `-`, `_` and `.`.
  - Tags can have their names delimited by a `.` in order to create a "hierarchy", e.g.
    `document.meta`.
  - \
    After a {# whitespace} character any number of parameters on the same line may follow:
    @code norg
    #tag-name.subtag parameter1 parameter2
    @end
    By default parameters are space-separated. In order to create multi-word parameters, you may
    escape the space character with a backslash (`\`).
    @code norg
    #tag-name.subtag parameter1\ with\ spaces parameter2
    @end
    Parameters may consist of any character (apart from a {# line break}, of course).
    ---

   Norg provides several inbuilt tag names that are reserved, but their details are not explained
   in this specification - this document strictly covers syntax. There is no restriction in regards
   to the length of a tag name, nor are there any disallowed names that a parser should omit
   (unless they don't adhere to the above rules regarding tag names).

** Macro Tags
   Macros are explained further in detail {** Macros}[in their own section].

   The `=` tag invokes a macro and injects its result into the location that the macro tag was invoked.

   Example: `=MyMacro myparameter`.

** Carryover Tags
   Carryover tags are a construct used to assign certain properties to the next item or whole object.
   In reality, they are a type of {** macro tags}[macro tag], where the next element is given as the
   last parameter to the macro. For more info see the {:semantics:} document %TODO: create semantics
   document%.

   There are two types of carryover tag, the {*** weak carryover tags}[weak carryover tag] and the
   {*** strong carryover tags}[strong variant].

*** Weak Carryover Tags
    The weak carryover tag affects the next element and next element /only/. It does not work with
    whole collections of elements (see {*** strong carryover tags}).

    Weak carryover tags only apply to the next element; they behave this way in the following
    contexts: %TODO: discuss%
    - When the element has children, the weak carryover tag only applies to the single item (it does
      not carry over to its children).
    - When the element is part of an {# object}, no other items other than the item below
      the weak carryover tag is affected.

**** Examples
     Only the second item is affected:
     @code norg
     - List item 1
     +color red
     - List item 2
     - List item 3
     @end

     Only the `Heading 1` and `This is some content` text is highlighted:
     @code norg
     +color red
     * Heading 1
       This is some content.
     ** Heading 2
        This is also some content.
     @end

*** Strong Carryover Tags
    Contrary to its weak variant, the strong carryover tag exists to annotate an entire
    {# object} versus just a single item. Its behaviour is opposite to its weak
    counterpart, namely:
    - When the element has children, the strong carryover tag applies to both the whole item and all
      of its children.
    - When the element is part of an {# object}, all items in the object are affected.

**** Examples
     A nice use case is the `#choice` carryover tag, which converts all items in a list into a
     single-choice question with right/wrong answers:
     @code norg
     What is your favourite activity? Hint: there's only one correct answer :)
     #choice
     - | | Sleeping
     - | | Learning
     - |x| Writing `.norg` documents
     @end

     Here, both the level 1 heading and the level 2 heading along with their contents will be
     coloured red:
     @code norg
     #color red
     * Heading 1
       This is some content.
     ** Heading 2
        This is also some content.
     @end

** Ranged Tags
   Ranged tags are a way to express custom information within a range.
   They begin with the traditional tag declaration and are ended with an `end` statement.

   The `end` statement has a simple ruleset:
   - Must be at the start of a line, may be preceded by any whitespace (but nothing else)
   - Must use the same prefix as its parent (in the case of standard ranged tags: `|`; in the case
     of verbatim tags: `@`)
   - Must not be succeeded by anything other than a {# line break}.

*** Standard Ranged Tags
    There are times where you may want to create an isolated block of Norg markup.
    To do this you may use the standard ranged tag, which uses the `|` character.

    Currently it's only used for two tags, `comment` and `example`. The `comment` ranged tag is used
    for long strings of comments (versus the `%` attached modifier, which is mostly used for short
    comments), whereas the `example` tag is a simple way to show an example of some Norg markup
    without it being rendered and treated as physical markup (most commonly used throughout this
    very document to show unrendered examples of Norg syntax).

**** Examples
     `|example`:
     @code norg
     |example
     * This is an example heading.
     |end
     @end

     `|comment`:
     @code norg
     |comment
     This is a very long comment with some content
     and with some markup!

     * Heading
       /italic/ and *bold*.
     |end
     @end

*** Verbatim Ranged Tags
    In other cases you may be more interested in a {# verbatim ranged tags}[verbatim ranged tag],
    which disallows any Norg markup to exist inside of itself. A prime example of this is `@code`,
    which creates a code block - you obviously don't want nested Norg syntax within that! Note how
    in the following example the `@MyAnnotation` would clash with Norg's verbatim ranged tag syntax.
    @code java
    @MyAnnotation(name="someName", value="Hello World")
    public class TheClass {
      // ...
    }
    @end
    This ranged tag type is the most commonly used one as it has the widest range of applications.
    The {*** standard ranged tags}[standard ranged tag] is a much more niche syntax element targeted
    at specific use cases.

* Attached Modifiers
  We can now discuss attached modifiers (which originally gave rise to the name of
  {# detached modifiers} as their natural counter-parts). Here are the general rules for attached
  modifiers:
  - An opening modifier may only be preceded by {# whitespace} or {# punctuation}
  - An opening modifier may _NOT_ be succeeded by {# whitespace}
  - A closing modifier may _NOT_ be preceded by {# whitespace}
  - A closing modifier may only be succeeded by {# whitespace} or {# punctuation}
  +name attached modifier range
  - \
     {# Attached modifiers} can only span at maximum a single {# paragraphs}[paragraph], i.e. they get
     terminated as soon as they encounter a {# paragraph break}.

     This means that this:
     @code norg
     *this

     text*
     @end
     Will *not* result in any bold text, as it's divided by a {# paragraph break}.
     However, this:

     @code norg
     *this
     text*
     @end
     Is fine, and will result in *`this text`* being bold.
  - Nested {# attached modifiers} should be closed in the opposite order they were opened.
  - Two or more consecutive attached modifiers of the same type (i.e. `**`, `//` etc.) should be
    instantly "disqualified" and parsed as raw text in /all/ circumstances and without any
    exceptions.

  Their name should be rather self explanatory - both the opening and closing modifier are attached
  to one another.

  The following attached modifiers exist and have respective meaning:
  - \*bold\*: *bold*
  - \/italic\/: /italic/
  - \_underline\_: _underline_
  - \-strikethrough\-: -strikethrough-
  - \!spoiler\!: !spoiler!
  - \^superscript\^: ^superscript^ (cannot be nested into `subscript`)
  - \,subscript\,: ,subscript, (cannot be nested into `superscript`)
  - \`inline code\`: `inline code` (disables any nested markup - verbatim)
  - \%inline comment\%: %inline comment%
  - \$inline math\$: $f(x) = y$ (verbatim)
  - \&variable\&: &variable& (verbatim)

** Valid Examples
   @code norg
   *Bold text*

   *Bold text*,
   .*Bold text*,

   *Bold
   text*

   */Bold and italic/* <- closing modifiers closed in the opposite order they were opened
   */Bold and italic/ and only bold*

   Text */with/ _different_ ^markup^ !types!*
   @end

** Invalid Examples
   @code norg
   * Bold text *

   *Bold text *

   other text*Bold text*

   *Bold text*other text

   *
   Bold text*

   *Bold
   text
   *

   *Bold

   text*

   Closed in the wrong order:
   */Bold and italic*/

   Also closed in the wrong order:
   */Bold and italic* and only italic/
   @end

** Free-form Attached Modifiers
   Even with all the rules described in the above sections there are still some evident limitations
   with attached modifiers, namely:
   - Arbitrary {# whitespace} within {# attached modifiers} is not permitted: `*  bold  *` is
     invalid.
   - Representing verbatim attached modifier chars within the corresponding verbatim blocks is not
     possible: \`I cannot place a (\`) char inside here without accidentally terminating the
     block.\`.
     %TODO: fix formatting%.

   Free-form modifiers fix this with a special syntax to specify the
   beginning and end of a ranged block. For example:
   @code norg
   Here, I can write `| leading and trailing whitespace (with a ` char)  |` within a verbatim block
   without accidentally terminating it.
   @end
   @code norg
   Here, I can use a literal `$` inside of inline math: $| 10$ + 10$ = 20$ |$.
   @end

   The use of pipes is special because the position of the pipe (i.e. whether it's before or after the
   attached modifier) can unambiguously tell us whether that symbol is an opening attached modifier
   or a closing one. It's thanks to this that whitespace is freely allowed within its content.

   Aside from the details described above, free-form attached modifiers have the following properties:
   - Backslashes (`\`) are treated as verbatim and do not mean an {*** escaping}[escape sequence]
     (see {* precedence}).
   - Despite being called "free-form" they can still only span a single paragraph (see {# attached
     modifier range}).

** Link Modifier
   The link modifier, `:`, is a special modifier type called an _intersecting_ modifier. It puts a
   twist on the original attached modifier rules - in fact, it's the polar opposite.

   As described in the {# attached modifiers} section, attached modifier types may not exist
   inbetween words like so:
   @code norg
   abso/freaking/lutely!
   @end

   It's entirely plausible to want to do this however, which is why the {** link modifier}[link
   modifier] was devised. With it, you can bridge attached modifiers and regular text together:
   @code norg
   abso:/freaking/:lutely!
   @end

   It is important to note that link modifiers do not need to occur in pairs. This:
   @code norg
   Ex:*ample* text
   @end
   Will also result in `ample` becoming *bold*. In fact, using a link modifier at the end will not
   give the desired result (it will be rendered as a regular `:` char). To understand why keep
   reading.

   Through the examples above it is evident that there are two link modifier types: one where the
   link modifier is an /opening/ link modifier (i.e. it appears before an opening attached modifier)
   and one where it's a /closing/ link modifier (i.e. it appears after a closing attached modifier).
   This distinction is visible even when they don't occur in pairs.

   In the case that the link modifier is opening (the attached modifier appears on the right):
   - The link modifier may only be preceded by an {# alphanumeric characters}[alphanumeric character]
     (or, in other words, may /not/ be preceded by a punctuation character nor by a whitespace
     character).
   - The link modifier may only be succeeded by an opening attached modifier.

   In the case that the link modifier is closing (the attached modifier appears on the left):
   - The link modifier may only be preceded by a closing attached modifier.
   - The link modifier may only be succeeded by an
     {# alphanumeric characters}[alphanumeric character].

   If the above conditions are not met, then the character should be treated as a literal `:`.

** Attached Modifier Extensions
   Similarly to {** detached modifier extensions}, {** attached modifier extensions} serve as a way
   to attach metadata to {* attached modifiers}.
   The metadata that you can attach however differs from {** detached modifier extensions}, as they
   serve different usecases.

   The content of {** attached modifier extensions} consists of a set of references to many
   {*** Attribute}[attributes]. These attributes are delimited by the contextual delimiter `|`.

*** Examples
    @code norg
    `print("This is some python")`(python) <- The python attribute highlights the text as python
    *print("This is some python too")*(python) <- Yes, this is Norg markup highlighted as python.
                                                  Don't know why you'd do it but hey you do you.
                                                  %TODO: can attributes impose limits?%

    {* Link location}[this is an important link](important|red) <- Highlights the link as big & bold
                                                                   and red.
    @end

* Multifunctional `|` Delimiter
  %TODO%

* Trailing Modifier
  Trailing modifiers are another separate kind of modifiers in the Norg syntax. They have one very
  simple rule: they may only exist at the end of a line and may not be followed by any characters
  after themselves.

** Line Continuation
   The `~`-trailing modifier will concatenate the line which it ends with the following one.
   This allows you to do something like the following:

   @code norg
   * I am a very long heading title~
     which did not end here because of the trailing modifier
   @end

   Note, that the `~`-trailing modifier will concatenate the two lines with a single separating
   whitespace. In other words it transforms a line ending, `\n`, into a single white space, |` `|.

   It completely swallows the next line break, allowing for things like this:
   @code norg
   - I am a list item~

   - And I am still the same list
   @end

   Without the trailing modifier those two items would have been treated as two separate lists, but
   since the `~` char swallows the line break it makes the parser actually see:
   @code norg
   - I am a list item
   - And I am still the same list
   @end

   Note that trailing modifiers may also exist on a separate line:
   @code norg
   - I am a list item
   ~
   - And I am still the same list
   @end

   Be aware however, that detached modifiers take {# Precedence} over trailing modifiers. So in the
   following, you will still be obtaining the list item, despite of the trailing modifer ending the
   previous paragraph:
   @code norg
   That's when she opened the box~
   - she couldn't believe what she saw.
   @end

   If you want to change this, you need to escape the detached modifier in order to make it part of
   the paragraph, treating this specific example like a sentence with a hyphen between its two
   parts:
   @code norg
   That's when she opened the box~
   \- she couldn't believe what she saw.
   @end

* Linkables
  Finally, there is one more kind of in-line syntax which is the {# linkables} kind.
  Linkables can link to any element /anywhere/ in the document.

  When resolving links, the first match should always be the only match, starting from the top of
  the document and heading towards the bottom. This means that if there are two matches, the one at
  the topmost part of the document should be chosen as the target.

  Linkables are comprised of many segments, and can change meaning depending on the order those
  segments were defined:

** Link Location
   The link location is defined through curly braces (`{}`) and contains the physical location
   that the user would like to link to. Inside of these curly braces you can find one of five
   types of data:
   - A {# file location}
   - A URL (most commonly to an external resource)
   - A {# detached modifier} followed by the name of the linkable
   - A {# custom detached modifiers}[custom detached modifier] specifically made for links
     (`/`, `#`)
   - | | time stamps (see also earlier)

*** File Location
    The file location is a construct that allows you to specify the /target file/ in which you want
    to make a link inside of. This allows you to *link to targets within other files* or just link
    to other norg files entirely.

    When standalone, the link syntax will simply point to another `.norg` file relative to the
    current file the link is contained in:

    @code norg
    {:path/to/other-file:}
    @end

    Note that you do *not* provide the `.norg` extension within the path.
    You can use traditional modifiers in your path, like `/` (in e.g. `/my/file`) to signify the
    root of your filesystem, `~` (in e.g. `~/Documents/my-file`) to signify the current user's home
    directory, /or/ you can use the [Neorg]-specific `$` (in e.g. `$/my/file`) to signify the _root_
    of the [Neorg] workspace.
    Since not all Norg files will be used strictly by [Neorg], the workspace root can be
    implementation-specific - for git repos the workspace root could be simply the root of the
    repository, and for other note taking apps it could simply be the root of the directory where
    all the notes are stored.

    A file location may /only/ be accompanied by a {# detached modifier} or the
    {# The Magic Char (`#`)}[the magic char], in which case the link looks like so:

    @code norg
    {:path/to/file:# Location within that file}
    {:path/to/file:** Level 2 heading}
    @end

    `/`, `@` and URLs are not allowed:

    @code norg
    {:path:/ file} <- invalid
    {:path:@ timestamp} <- invalid
    {:path:https://my-url} <- also invalid
    @end

*** URL
    You can define a link to an external resource by simply putting in the URL:

    @code norg
    {https://github.com/nvim-neorg/neorg}
    @end
    Actions related to schemas like `https://`, `ftp://` etc. (when attempting to open the link) are
    handled by a lower level component running Norg, e.g. [Neorg] or the underlying Operating
    System.

*** Detached Modifier
    Norg allows you to link to any {# Structural Detached Modifiers}[structural] or
    {# Range-able Detached Modifiers}[range-able] detached modifier:

    @code norg
    * I am a level 1 heading

    Strict link to a level 1 heading:
    {* I am a level 1 heading}
    @end

    The inside of the link location looks just like a detached modifier definition, and that is
    because it pretty much is. You can substitute the `*` char for any other
    {# Structural Detached Modifiers}[structural] or {# Range-able Detached Modifiers}[range-able]
    detached modifier, /except/ "ranged" versions of said modifiers - those are *disallowed* within
    the link syntax. By this we mean that syntax like `{$$ Text}` is _invalid_. To link to a ranged
    definition you would still use `{$ Text}`, there is no reason to make a distinction between a
    ranged and non-ranged detached modifier as both have the same meaning, one just allows more
    content to exist within itself.

    NOTE ! You /cannot/ link to a logical %TODO: link% modifier using {* linkables}. Things like
    {*** macros} and {*** variables} are out of the equation.

*** Custom Detached Modifiers
    Apart from linking to the detached modifiers outlined above, you can also link to a set of
    custom modifiers specifically designed for links. These are the `#` (magic), `/` (file), `@`
    (timestamp) and `?` (wiki link) linkable locations.

**** The File Linkable (`/`)
     Sometimes you may want to link to an external file that is not a Norg file.
     In that case you may use `{/ /path/to/my/file.txt}` (notice the mandatory space after the `/`
     char, just like with the {# detached modifier}s). Paths are relative to the Norg
     file that contains the link.

     In addition to just providing a path, you may also specify a line number at the end via a colon `:`.
     Example:
     @code norg
     {/ my-file.txt:123} <- This is a link to `my-file.txt` at line 123
     @end
     As with the {# file location} syntax, the file linkable also supports the special `$` character
     to denote the root of the current workspace.

**** Timestamps (`@`)
     The syntax for timestamps within links is the same as the syntax used in the
     {**** timestamp extension}.

     Example:
     @code norg
     Frank's birthday is on {@ Mon 5th May 2023}.
     @end

**** The Magic Char (`#`)
     Sometimes you simply want to be lazy, or you want to link to an {# inline linkables}[inline
     linkable] that does not have a dedicated modifier to denote it - in these scenarios you would
     use the magic char: `#`. It links to /any/ item type. The syntax is exactly the same as with
     the other modifiers: `{# My Location}`.

**** Wiki Links (`?`)
     When building large knowledge bases it's sensible to want to quickly create links between files
     without worrying about the location of said file. The *wiki link* allows you to link to any
     heading in any file in the current workspace. You don't specify any filepaths within the link,
     just the title of the heading you want to search for.

     Syntax:
     @code norg
     Cats are {? mammals}, they make for great {? house pets} too!
     @end
     For developers implementing this behaviour: there are no restrictions in which order you parse
     your files to hop between wiki links, as long as the following coniditions are met:
     - The current file is the first file that is searched (this allows for `?` to also work as a
       generic catchall link for all heading levels)
     - All files in the current workspace are parsed/enumerated (including subdirectories)

     %TODO: does the `{:file:}` syntax work with wiki links?%

*** Inline Linkables
    Although most linkable items are either {# Structural Detached Modifiers}[structural] or
    {# Range-able Detached Modifiers}[range-able], there are also syntax elements in Norg that
    are inline - these are the `#name` {# Carryover Tags}[carryover tag] and the
    {# Inline Link Target}[inline link target]. Both of these can be linked to through the
    {# The Magic Char (`#`)}[the magic char].

*** Differences Between File Linkables
    You may have realized that there are many different ways to reference a file:
    - `{:my/file:}`
    - `{/ my/file.norg}`
    - `{file://my/file.norg}`

    Why are there this many?
    ~ `{:my/file:}` is strictly to access `.norg` files and nothing else. More specifically, it's
       designed to access a resource /within/ a file (`{:my/file:* Heading}`), with the side effect
       of being able to also exist in a standalone fashion (`{:my/file:}`).
    ~ `{/ my/file.norg}` is used to link to a file and a file /only/ (vs `{:my/file:* Heading}`
       which links to an element within a file). Although it /can/ link to `.norg` files, its main
       use is to link to non-`.norg` files instead. Using the `/` syntax also disallows you from
       accessing items within the file.
    ~ `{file://my/file.norg}` is simply utilizing the `file://` schema to access a file. This
       isn't /the/ recommended way to link to files, but it exists simply because of URI schemas.

** Link Description
   Link descriptions are denoted by square brackets: `[]`. They contain the description for either a
   {# link location} (by placing the description after the link location), an {# anchors}[anchor]
   definition (by placing the description before the link location) or an anchor declaration (where
   the /only/ syntax item *is* the link description). Anchors are described {# anchors}[later on].

** Links
   Links in Norg can exist as a standalone {# link location} in which case their text is used as
   the link title (often makes sense for headings):

   @code norg
   {* I am a standalone link}
   @end

   When a custom description is required, it must be placed *_after_* the link location. This makes
   sense in terms of writing as you first define where you link to, and then annotate it afterwards:

   @code norg
   Click {* I am a link}[here] to find out more.
   @end
** Anchors
   Norg also has a concept called {# anchors}. These allow you to place a standalone
   {# link description} inside of text (referred to as an <anchor declaration>).
   The target which this anchor links to can then be _defined_ at another place in the document
   with an <anchor definition> which is an initial {** link description} followed by a
   {** link location}. This is especially useful when you want to link to the same target very
   often, like for example a specific website.

   Few usage examples:
   @code norg
   [Neorg] is a fancy organizational tool for everyone.

   I like shilling [Neorg]{https://github.com/nvim-neorg/neorg} sorry :(
   @end
   Here we /declare/ the anchor once at the top, then /define/ the anchor at the very bottom. The
   `[Neorg]` declaration points directly to the website, just like the definition does. It's like a
   copy + paste of the link location without needing to type it out.

   Other than the declaration behaviour described above anchors have no other special meaning and/or
   semantics, and behave just like regular {** links} do. This means they can be used as a
   substitute for regular {** links} should the user prefer the "description + location" syntax
   versus the "location + description" syntax.

   Anchors (like {# links}) may also be described by using `[...]`, in which case the syntax looks
   like this: `[anchor name][anchor description]`.

** Inline Link Targets
   Finally, Norg also has the possibility of placing link targets at arbitrary in-line positions
   in your document. We call these {# inline link targets} which are formatted inside of angled
   brackets: `<>`.

   @code norg
   One thing to mention is <inline link targets> - they allow you to link to any location in a
   document.

   ...

   Refer to {# inline link targets} if you are interested in learning more.
   @end

   An important thing to note is that since inline link targets are - well - inline, they cannot be
   directly linked to with a dedicated char in the link syntax.
   To link to these syntax elements you can /only/ use {# The Magic Char (`#`)}[the magic char].

   Unlike {# links} and {# anchors}, {# inline link targets} may /not/ have a description.

** Valid/Invalid Examples
*** Valid Examples
    @code norg
    {link}

    {:link:}

    {# link
       text}

    {* a link
    to a heading}

    {* a
    link to a heading}[with
    a description]

    [te
    xt]{# linkable}

    {* Link to {# headings}[heading]}[*markup*]
    @end

*** Invalid Examples
    @code norg
    {*text}

    {:file:https://github.com}
    {:file:/ file.txt}
    {:file:@ Wednesday 30th Jan}

    {* 
    text}

    {
    * text}

    {* some
    text   } %TODO: whitespace is no longer around at linkable boundaries%

    {
        * text
    }

    {* text
    }

    { * text}

    {* text}[
        text
    ]

    {* text}[text
    ]

    {* text}[
    text]
    @end

* Standard Library
  Norg comes loaded with a predetermined set of {*** attributes} and {*** macros} for different
  {:layers:} of the syntax. These will eventually be described here, or within the layers document
  itself.

* Precedence
  Precedence in Norg is rather simple and intuitive. All non-inline elements have direct
  precedence over all inline elements. Inline elements with a deterministic start and end have
  greater priority than those that don't. Verbatim elements have greater priority than non-verbatim
  elements.

  Here's the full list:
  ~ Tags (`#infecting`, `+carryover`, `|standard`, `@verbatim` and `=macro`)
  ~ Structural detached modifiers
  ~ Nestable detached modifiers and range-able detached modifiers (there isn't a case where these
    can overlap)
  ~ Detached modifier extensions
  ~ Linkables (`{}`, `[]`, `<>`)
  ~ Free-form verbatim attached modifiers (`\|``|`, `\|``|`)
  ~ Escape character (`\`)
  ~ Free-form attached modifiers
  ~ Free-form modifiers (`|**|`, `|//|` etc.)
  ~ Standard attached modifers

  - | | clarify trailing modifier precedence

  Should any extra precedence problems arise (let us know if you find any) they can be disambiguated
  through a simple left-to-right precedence approach.

  Note that although e.g. linkables are above standard attached modifiers, this does not mean that
  standard attached modifiers cannot /contain/ linkables, but in case there is an overlap the
  linkable will have higher precedence.

  For example, this is valid:
  @code norg
  *{# i am a bold link!}*
  @end

  However, in this case:
  @code norg
  *am I {* bold?} - No!
  @end
  The link takes precedence, and no bold is rendered.
  ===

%| vim: set tw=100 :|%
